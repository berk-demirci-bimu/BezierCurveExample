

#include <windows.h>
#include "GL/glut.h"
#include <stdio.h>
#include <math.h>

void display();
void arkaPlanRenk();
void bezierCurve(float);
void coordinates();


float P[4][2];
float bezierX;
float bezierY;
float sonucX = 0;
float sonucY = 0;


int main(int argc, char** argv) {
	
	P[0][0] = 0;
	P[0][1] = 0;
	P[1][0] = 0.3f;
	P[1][1] = 0.8f;
	P[2][0] = 0.9f;
	P[2][1] = 0.8f;
	P[3][0] = 1;
	//P[3][1] = 1;
	P[3][1] = 0;
	char c[10];
	int i;
	int bitt = 0;

		printf("Would you want to use default values? Enter 1 for Yes, 0 for No");
		
		i = 0;
		bitt = 0;
			while (i != 1){
				
				
				scanf_s("%d", &bitt);
				
				switch (bitt) {

				case 0:
					coordinates();
					i = 1;
					break;
				case 1:
					i = 1;
					break;
				default:
					i = 0;
					printf("You entered wrong value %d",bitt);
					break;
				}
				
			}
	





	bezierCurve(0.25f);
	glutInit(&argc, argv);
	glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB);
	glutInitWindowSize(800, 600);
	glutInitWindowPosition(0, 0);
	glutCreateWindow("1306160028");
	glutDisplayFunc(display);
	arkaPlanRenk();
	glutMainLoop();
}

void arkaPlanRenk() {
	glClearColor(0.9, 0.9, 1, 0.0); 

	//glColor3f(0.314, 0.314, 0.000);

	glLoadIdentity();
}

void display() {
	glClear(GL_COLOR_BUFFER_BIT);

	//X axis
	glBegin(GL_LINES);
	glVertex2f(-4.0f, 0.0f);
	glVertex2f(4.0f, 0.0f);
	glEnd();

	//Y axis
	glBegin(GL_LINES);
	glVertex2f(0.0, -4.0f);
	glVertex2f(0.0, 4.0f);
	glEnd();
	glFlush();


	//Real path generated by values of **P
	glColor3i(100, 100, 200);
	glBegin(GL_LINES);

	for (int i = 0; i <= 2; i++) {
		glVertex2f(P[i][0], P[i][1]);
		glVertex2f(P[i+1][0], P[i+1][1]);
	}
	glEnd();
	glFlush();



	//Thicker line, default value is 1
	glLineWidth(1.5f);
	glColor3f(0.5f, 0.5f, 1);

	//Drawing Bezier Curve
	glBegin(GL_LINES);
	
	
	for (float t = 0.0f; t <= 1.0f; t += 0.01f) {
		
		bezierCurve(t);
		glVertex2f(bezierX,bezierY);
		printf("%2.5f\n", bezierX);
	}

	glEnd();
	glFlush();

	
	
}

void bezierCurve(float t) {

	//Bezier curve formula
	
	bezierX = pow(1 - t, 3)*P[0][0] + 3 * pow(1 - t, 2)*t*P[1][0] + 3 * (1 - t)*pow(t, 2)*P[2][0] + pow(t, 3)*P[3][0];
	bezierY = pow(1 - t, 3)*P[0][1] + 3 * pow(1 - t, 2)*t*P[1][1] + 3 * (1 - t)*pow(t, 2)*P[2][1] + pow(t, 3)*P[3][1];
		
}


void coordinates() {
	int a;
	
	printf("Enter the position of points. (min: -100) (max: 100) \n");
	for (int i = 0; i < 4; i++) {
		
		printf("X%d: ",i);
		scanf_s("%d", &a);
		
		P[i][0] = (float) a/100;

		printf("Y%d: ", i);
		scanf_s("%d", &a);
		P[i][1] = (float)a / 100;
		if (P[i][0] > 1 || P[i][1] > 1) {
			i = i - 1;
			printf_s("(x,y) values are out of range. Please re-enter the values again. Range: (-100,100)\n");
		}
	}

}